This problem can be solved using Binary Search. We define two pointers, where one is further than the other. I called these left and right. We find the midpoint of these pointers and check if isBadVersion(version) returns true. If it is true, this means the first bad version could be less than or equal to the current midpoint. To avoid checking the versions after the midpoint, we can set our right pointer to the midpoint. This would check the versions from 1 to the current midpoint. If it is false, this means the first bad version comes after the current midpoint, so we move the left pointer to avoid checking the versions before the midpoint. Keep repeating these checks (loop) until left and right pointers meet each other. Finally, we can return either the left or right pointer, since both are equal. This pointer indicates the first bad version.
