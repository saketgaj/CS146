The approach I used is a graph and topological sorting method. The first step is to a graph that represents the prerequisites for each course. Do this by creating a list of lists and each inner list represents the adjacency list for that course. Then you populate the graph using the given prerequisite array. The next step is to create a method called hasCycles() which uses DFS to detect the cycles/loops in the graph. We use 0 to represent unvisited, 1 to represent visiting, and 2 to represent already visited. First, check if the current course is visiting (1), and this means a cycle is found so return true. Then, check the current course is already visited (2), which means no cycle is found, so return false. If these checks pass, then mark the current course as visiting (1), and use recursion to explore its neighbors. Finally, mark the course as visited (2).
